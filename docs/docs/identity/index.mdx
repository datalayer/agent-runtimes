---
title: Identity
---

# Identity

AI agents that act on behalf of users need secure identity and authorization mechanisms to access external services like GitHub, Gmail, Kaggle, or enterprise APIs. This section describes the identity strategy for Agent Runtimes.

## Overview

Agent identity is more complex than traditional application identity because:

1. **Delegation**: Agents act *on behalf of* users, requiring clear authorization chains
2. **Multi-service access**: A single agent may need tokens for GitHub, Gmail, Slack, and more
3. **Dynamic tool discovery**: Agents discover MCP servers at runtime, requiring dynamic credential management
4. **Autonomy vs. control**: Balancing agent autonomy with user oversight and consent

```
┌─────────────────────────────────────────────────────────────────────┐
│                         User (Resource Owner)                        │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                         OAuth 2.1 Authorization
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│                        Agent Runtimes Server                         │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────────┐  │
│  │  Token Manager  │  │  Agent Context  │  │  MCP Client         │  │
│  │  (OAuth flows)  │  │  (User identity)│  │  (Tool invocation)  │  │
│  └────────┬────────┘  └────────┬────────┘  └──────────┬──────────┘  │
└───────────┼────────────────────┼───────────────────────┼────────────┘
            │                    │                       │
            ▼                    ▼                       ▼
     ┌──────────────┐     ┌──────────────┐       ┌──────────────┐
     │   GitHub     │     │   Gmail      │       │  Kaggle MCP  │
     │   API        │     │   API        │       │  Server      │
     └──────────────┘     └──────────────┘       └──────────────┘
```

## Identity Types

### Type 1: User-Delegated Access (OAuth 2.1)

**Use case**: Agent accesses user's GitHub repositories, Gmail, or other personal services.

The agent acts as an OAuth client, obtaining tokens that represent the user's delegated authorization. This follows the standard [OAuth 2.1](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12) authorization code flow with PKCE.

```python
# User initiates OAuth flow through the UI
# Agent receives delegated access token
agent_context = AgentContext(
    user_id="user-123",
    oauth_tokens={
        "github": GitHubToken(access_token="gho_...", scopes=["repo", "read:user"]),
        "gmail": GmailToken(access_token="ya29...", scopes=["gmail.readonly"]),
    }
)

# Agent tools use these tokens
@agent.tool
async def list_repos(ctx: RunContext[AgentContext]) -> list[dict]:
    token = ctx.deps.oauth_tokens["github"]
    async with httpx.AsyncClient() as client:
        response = await client.get(
            "https://api.github.com/user/repos",
            headers={"Authorization": f"Bearer {token.access_token}"}
        )
        return response.json()
```

### Type 2: MCP Server Authentication

**Use case**: Agent connects to an MCP server that requires OAuth authentication (e.g., [Kaggle MCP](https://www.kaggle.com/docs/mcp)).

MCP servers follow the [MCP Authorization Specification](https://modelcontextprotocol.io/specification/2025-03-26/basic/authorization) based on OAuth 2.1.

```json
{
  "mcpServers": {
    "kaggle": {
      "url": "https://www.kaggle.com/mcp",
      "auth": {
        "type": "oauth2",
        "clientId": "your-client-id",
        "scopes": ["datasets:read", "notebooks:execute"]
      }
    }
  }
}
```

When the agent invokes a Kaggle MCP tool, the runtime:
1. Checks if a valid token exists for this user + MCP server
2. If not, initiates OAuth flow (user sees consent screen)
3. Stores the token securely
4. Attaches token to MCP requests

### Type 3: Agent-to-Agent Communication (SPIFFE/SPIRE)

**Use case**: Internal agents communicating within your organization's infrastructure.

For workload-to-workload identity within a trust domain, use [SPIFFE](https://spiffe.io) (Secure Production Identity Framework for Everyone):

```python
from agent_runtimes.identity import SPIFFEIdentity

# Agent obtains its SVID (SPIFFE Verifiable Identity Document)
identity = SPIFFEIdentity()
svid = await identity.get_x509_svid()

# Use SVID for mutual TLS with other agents
async with identity.create_secure_channel("spiffe://acme.com/agents/data-processor") as channel:
    response = await channel.request({"action": "process_data", "payload": data})
```

SPIFFE provides:
- **Automatic identity**: No static credentials—workloads receive short-lived certificates
- **Zero-trust**: Every request is authenticated via mutual TLS
- **Cross-platform**: Works with Kubernetes, VMs, bare metal

### Type 4: Service Account Access

**Use case**: Agent accesses backend services using application-level credentials.

For server-to-server communication where no user is involved, use the OAuth 2.1 Client Credentials flow:

```python
from agent_runtimes.identity import ServiceCredentials

# Configure service account
service = ServiceCredentials(
    client_id=os.getenv("ANALYTICS_CLIENT_ID"),
    client_secret=os.getenv("ANALYTICS_CLIENT_SECRET"),
    token_endpoint="https://auth.example.com/oauth/token",
    scopes=["analytics:read"]
)

# Agent uses service token (auto-refreshed)
@agent.tool
async def get_metrics(ctx: RunContext) -> dict:
    token = await service.get_token()
    # Use token for API calls
```

## Provider Setup Guides

This section provides step-by-step instructions for setting up OAuth with common providers.

### GitHub OAuth App Setup

For GitHub identity, you need to create a **GitHub OAuth App** (not a GitHub App). OAuth Apps are simpler and suitable for user authentication flows.

:::info GitHub OAuth App vs GitHub App
- **OAuth App**: Simple user authentication, suitable for Agent Runtimes identity
- **GitHub App**: More complex, designed for installations on repos/orgs, has webhooks and granular permissions

For Agent Runtimes identity features, use an **OAuth App**.
:::

#### Step 1: Create the OAuth App

1. Go to [GitHub Developer Settings](https://github.com/settings/developers)
2. Click **OAuth Apps** in the left sidebar
3. Click **New OAuth App** (or **Register a new application**)

#### Step 2: Configure the Application

Fill in the registration form:

| Field | Value | Notes |
|-------|-------|-------|
| **Application name** | `My Agent App` | User-visible name shown during authorization |
| **Homepage URL** | `http://localhost:3000` | Your application's homepage (can be localhost for dev) |
| **Application description** | Optional | Helps users understand what your app does |
| **Authorization callback URL** | `http://localhost:3000/oauth/callback` | **Critical**: Must match your app's callback route |

:::warning Callback URL
The callback URL must exactly match what your application uses. For development:
- `http://localhost:3000/oauth/callback` (Vite default port)
- `http://localhost:3063/oauth/callback` (Agent Runtimes example)

For production, use your actual domain with HTTPS:
- `https://myapp.example.com/oauth/callback`
:::

#### Step 3: Get Your Credentials

After creating the app:

1. Copy the **Client ID** - this is public and safe to include in frontend code
2. Click **Generate a new client secret**
3. Copy the **Client Secret** immediately - it's only shown once!

:::danger Client Secret Security
- **Never** commit the client secret to version control
- **Never** include it in frontend/browser code
- Store it in environment variables or a secrets manager
- The client secret is only needed for the backend token exchange
:::

#### Step 4: Configure Agent Runtimes

**Frontend (React)**:

```tsx
// Set via environment variable (safe for frontend - public value)
// In .env or .env.local:
// VITE_GITHUB_CLIENT_ID=your_client_id_here

import { IdentityConnect } from '@datalayer/agent-runtimes';

function App() {
  return (
    <IdentityConnect
      providers={{
        github: {
          clientId: import.meta.env.VITE_GITHUB_CLIENT_ID,
          scopes: ['read:user', 'user:email', 'repo'],
        },
      }}
    />
  );
}
```

**Backend (Python)**:

```bash
# In your .env file (never commit this!)
GITHUB_CLIENT_ID=your_client_id
GITHUB_CLIENT_SECRET=your_client_secret
```

```python
# In your agent server configuration
import os

OAUTH_PROVIDERS = {
    "github": {
        "client_id": os.getenv("GITHUB_CLIENT_ID"),
        "client_secret": os.getenv("GITHUB_CLIENT_SECRET"),
        "authorization_endpoint": "https://github.com/login/oauth/authorize",
        "token_endpoint": "https://github.com/login/oauth/access_token",
        "userinfo_endpoint": "https://api.github.com/user",
    }
}
```

#### Step 5: Set Up the Callback Route

Mount the `OAuthCallback` component at your callback URL:

```tsx
// Using React Router
import { OAuthCallback } from '@datalayer/agent-runtimes';
import { Routes, Route } from 'react-router-dom';

function App() {
  return (
    <Routes>
      <Route path="/" element={<MainApp />} />
      <Route 
        path="/oauth/callback" 
        element={<OAuthCallback redirectUrl="/" />} 
      />
    </Routes>
  );
}
```

#### GitHub OAuth Scopes Reference

| Scope | Access | Use Case |
|-------|--------|----------|
| `read:user` | Read user profile | Basic identity verification |
| `user:email` | Read user email | Contact information |
| `repo` | Full repository access | Read/write code, issues, PRs |
| `public_repo` | Public repositories only | Read/write public repos |
| `repo:status` | Commit status | CI/CD integrations |
| `read:org` | Read org membership | Organization-aware features |
| `gist` | Create/read gists | Code snippet sharing |

**Recommended minimum scopes**: `read:user`, `user:email`

**For repository access**: Add `repo` (private) or `public_repo` (public only)

#### Testing Your Setup

1. Start your development server:
   ```bash
   npm run dev
   ```

2. Click "Connect GitHub" in your app

3. You should be redirected to GitHub's authorization page

4. After authorizing, you'll be redirected back to your callback URL

5. The `OAuthCallback` component handles the token exchange automatically

#### Troubleshooting

**"The redirect_uri is not valid"**
- Ensure your callback URL in GitHub settings exactly matches your app's URL
- Check for trailing slashes - `http://localhost:3000/oauth/callback` ≠ `http://localhost:3000/oauth/callback/`
- Verify the protocol matches (http vs https)

**"Bad credentials" on API calls**
- Token may have expired - implement token refresh
- Scopes may be insufficient - request additional scopes

**CORS errors**
- GitHub's token endpoint doesn't support CORS
- Token exchange must happen on your backend server
- Agent Runtimes provides `/api/v1/identity/oauth/token` endpoint for this

### Google OAuth Setup

For Google/Gmail identity, use Google Cloud Console:

1. Go to [Google Cloud Console](https://console.cloud.google.com/)
2. Create a project or select an existing one
3. Navigate to **APIs & Services** → **Credentials**
4. Click **Create Credentials** → **OAuth client ID**
5. Select **Web application**
6. Add authorized redirect URIs (same pattern as GitHub)
7. Copy the Client ID and Client Secret

```tsx
<IdentityConnect
  providers={{
    google: {
      clientId: import.meta.env.VITE_GOOGLE_CLIENT_ID,
      scopes: ['openid', 'profile', 'email', 'https://www.googleapis.com/auth/gmail.readonly'],
    },
  }}
/>
```

### Kaggle OAuth Setup

Kaggle uses OAuth 2.1 for MCP server authentication:

1. Go to [Kaggle Account Settings](https://www.kaggle.com/settings)
2. Scroll to **API** section
3. Create API credentials
4. Configure your MCP server connection:

```json
{
  "mcpServers": {
    "kaggle": {
      "url": "https://www.kaggle.com/mcp",
      "auth": {
        "type": "oauth2",
        "clientId": "your-kaggle-client-id",
        "scopes": ["datasets:read", "notebooks:read"]
      }
    }
  }
}
```

## Implementation Strategy

### Phase 1: OAuth 2.1 Foundation

Implement OAuth 2.1 with the following components:

```
agent_runtimes/
  identity/
    __init__.py
    oauth/
      client.py          # OAuth client implementation
      tokens.py          # Token storage and refresh
      pkce.py            # PKCE utilities
      discovery.py       # Authorization server metadata (RFC 8414)
      dcr.py             # Dynamic Client Registration (RFC 7591)
    providers/
      github.py          # GitHub OAuth configuration
      google.py          # Google/Gmail OAuth configuration
      kaggle.py          # Kaggle OAuth configuration
      generic.py         # Generic OAuth provider
```

#### Token Storage

Tokens must be stored securely with:
- **Encryption at rest**: AES-256 encryption for stored tokens
- **User scoping**: Tokens are always associated with a specific user
- **Automatic refresh**: Background refresh before expiration
- **Revocation support**: Clear tokens on user logout or revocation

```python
class TokenStore:
    """Secure token storage with automatic refresh."""
    
    async def store_token(
        self,
        user_id: str,
        provider: str,
        token: OAuthToken,
    ) -> None:
        """Store encrypted token for user."""
        
    async def get_token(
        self,
        user_id: str,
        provider: str,
    ) -> OAuthToken | None:
        """Get token, refreshing if needed."""
        
    async def revoke_token(
        self,
        user_id: str,
        provider: str,
    ) -> None:
        """Revoke and delete token."""
```

#### Dynamic Client Registration

For MCP servers the agent hasn't seen before, use [RFC 7591](https://datatracker.ietf.org/doc/html/rfc7591) Dynamic Client Registration:

```python
async def register_client(
    registration_endpoint: str,
    client_name: str,
    redirect_uris: list[str],
) -> ClientCredentials:
    """Dynamically register OAuth client with MCP server."""
    async with httpx.AsyncClient() as client:
        response = await client.post(
            registration_endpoint,
            json={
                "client_name": client_name,
                "redirect_uris": redirect_uris,
                "grant_types": ["authorization_code", "refresh_token"],
                "response_types": ["code"],
                "token_endpoint_auth_method": "none",  # Public client
            }
        )
        data = response.json()
        return ClientCredentials(
            client_id=data["client_id"],
            client_secret=data.get("client_secret"),
        )
```

### Phase 2: MCP Authorization Integration

Extend the MCP client to handle OAuth authentication automatically:

```python
class AuthenticatedMCPClient:
    """MCP client with automatic OAuth handling."""
    
    def __init__(
        self,
        server_url: str,
        token_store: TokenStore,
        user_id: str,
    ):
        self.server_url = server_url
        self.token_store = token_store
        self.user_id = user_id
        
    async def call_tool(
        self,
        tool_name: str,
        arguments: dict,
    ) -> Any:
        # Get or refresh token
        token = await self.token_store.get_token(
            self.user_id,
            provider=self._get_provider_key()
        )
        
        if token is None:
            # Trigger OAuth flow
            raise AuthorizationRequired(
                provider=self._get_provider_key(),
                auth_url=await self._get_auth_url(),
            )
        
        # Call MCP tool with authorization header
        headers = {"Authorization": f"Bearer {token.access_token}"}
        return await self._execute_tool(tool_name, arguments, headers)
```

### Phase 3: Token Broker Architecture (Advanced)

For production deployments with many connectors, consider a centralized token broker:

```
┌─────────────────────────────────────────────────────────────────────┐
│                         Token Broker                                 │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────────┐  │
│  │  Token Vault    │  │  Policy Engine  │  │  Audit Logger       │  │
│  │  (encrypted)    │  │  (scopes/limits)│  │  (compliance)       │  │
│  └────────┬────────┘  └────────┬────────┘  └──────────┬──────────┘  │
└───────────┼────────────────────┼───────────────────────┼────────────┘
            │                    │                       │
     ┌──────┴──────┐      ┌──────┴──────┐        ┌──────┴──────┐
     │   Agent 1   │      │   Agent 2   │        │   Agent N   │
     └─────────────┘      └─────────────┘        └─────────────┘
```

Benefits:
- **Centralized governance**: Admins control all token policies
- **Automatic rotation**: Tokens are refreshed before expiry
- **Audit trail**: Every token use is logged
- **Scoped access**: Agents only see tokens they're authorized for

## Security Best Practices

### 1. Use PKCE for All OAuth Flows

All authorization code flows MUST use [PKCE](https://oauth.net/2/pkce/) (Proof Key for Code Exchange):

```python
import secrets
import hashlib
import base64

def generate_pkce_pair() -> tuple[str, str]:
    """Generate PKCE code verifier and challenge."""
    code_verifier = secrets.token_urlsafe(64)
    code_challenge = base64.urlsafe_b64encode(
        hashlib.sha256(code_verifier.encode()).digest()
    ).decode().rstrip("=")
    return code_verifier, code_challenge
```

### 2. Minimize Token Lifetimes

- **Access tokens**: 1 hour maximum
- **Refresh tokens**: 7 days maximum, with rotation on use
- **MCP session tokens**: Scope to single session when possible

### 3. Request Minimum Scopes

```python
# ❌ Don't request broad scopes
scopes = ["repo", "user", "admin:org"]

# ✅ Request only what's needed
scopes = ["repo:read", "user:email"]
```

### 4. Implement Token Revocation

When a user disconnects a service or logs out:

```python
async def disconnect_provider(user_id: str, provider: str) -> None:
    """Revoke tokens and clean up."""
    token = await token_store.get_token(user_id, provider)
    if token:
        # Revoke at provider
        await provider_client.revoke_token(token)
        # Delete locally
        await token_store.delete_token(user_id, provider)
```

### 5. Secure Token Storage

Never store tokens in:
- ❌ Environment variables (except for local development)
- ❌ Browser localStorage/sessionStorage
- ❌ Unencrypted databases
- ❌ Log files

Instead use:
- ✅ Encrypted database columns
- ✅ Hardware security modules (HSM) for production
- ✅ Secret managers (Vault, AWS Secrets Manager, GCP Secret Manager)

## UI Integration

The Agent Runtimes React components support OAuth flows out of the box:

```tsx
import { ChatBase, useOAuthConnect } from '@datalayer/agent-runtimes';

function AgentChat() {
  const { connect, isConnecting, connectedProviders } = useOAuthConnect();
  
  return (
    <div>
      {/* Show connection status */}
      <div className="providers">
        <button 
          onClick={() => connect('github')}
          disabled={connectedProviders.includes('github')}
        >
          {connectedProviders.includes('github') ? '✓ GitHub Connected' : 'Connect GitHub'}
        </button>
        <button onClick={() => connect('kaggle')}>
          Connect Kaggle
        </button>
      </div>
      
      {/* Chat component handles authorization-required responses */}
      <ChatBase
        onAuthorizationRequired={({ provider, authUrl }) => {
          // Open OAuth popup
          window.open(authUrl, 'oauth', 'width=600,height=800');
        }}
      />
    </div>
  );
}
```

## Emerging Standards

### OpenID Connect for Agents (OIDC-A)

[OIDC-A 1.0](https://arxiv.org/abs/2509.25974) is an emerging extension to OpenID Connect specifically designed for LLM-based agents. Key features:

- **Agent identity claims**: Standard claims for agent type, capabilities, and attestation
- **Delegation chains**: Cryptographic proof of authorization delegation from user to agent
- **Capability tokens**: Fine-grained authorization based on agent capabilities

While OIDC-A is still emerging, Agent Runtimes will track its development and adopt relevant patterns as the specification matures.

### A2A Identity

The [A2A (Agent-to-Agent) protocol](https://google.github.io/a2a/) includes identity provisions for inter-agent communication, complementing the transports layer documented in [Transports](/transports).

## Configuration Reference

### Environment Variables

```bash
# OAuth provider credentials (for built-in providers)
GITHUB_CLIENT_ID=your-github-client-id
GITHUB_CLIENT_SECRET=your-github-client-secret

GOOGLE_CLIENT_ID=your-google-client-id
GOOGLE_CLIENT_SECRET=your-google-client-secret

# Token encryption key (required for production)
TOKEN_ENCRYPTION_KEY=your-256-bit-key-base64

# Token storage backend
TOKEN_STORE_TYPE=database  # or "memory", "redis", "vault"
TOKEN_STORE_URL=postgresql://user:pass@localhost/tokens
```

### MCP Server Authentication Config

```json
{
  "mcpServers": {
    "kaggle": {
      "url": "https://www.kaggle.com/mcp",
      "auth": {
        "type": "oauth2",
        "discoveryUrl": "https://www.kaggle.com/.well-known/oauth-authorization-server",
        "scopes": ["datasets:read", "notebooks:read"],
        "clientId": "your-kaggle-client-id"
      }
    },
    "github": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-github"],
      "env": {
        "GITHUB_TOKEN": "${GITHUB_USER_TOKEN}"
      }
    },
    "filesystem": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-filesystem", "/allowed/path"],
      "auth": null
    }
  }
}
```

## Further Reading

- [OAuth 2.1 Draft Specification](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12)
- [MCP Authorization Specification](https://modelcontextprotocol.io/specification/2025-03-26/basic/authorization)
- [SPIFFE Concepts](https://spiffe.io/docs/latest/spiffe-about/spiffe-concepts/)
- [RFC 7591 - OAuth 2.0 Dynamic Client Registration](https://datatracker.ietf.org/doc/html/rfc7591)
- [RFC 8414 - OAuth 2.0 Authorization Server Metadata](https://datatracker.ietf.org/doc/html/rfc8414)
- [PKCE (RFC 7636)](https://oauth.net/2/pkce/)
- [Secure Token Management for AI Agents](https://www.scalekit.com/blog/secure-token-management-ai-agents)
