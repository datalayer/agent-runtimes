---
title: Identity
---

# Identity

AI agents that act on behalf of users need secure identity and authorization mechanisms to access external services like GitHub, Gmail, Kaggle, or enterprise APIs. This section describes the identity strategy for Agent Runtimes.

## Overview

Agent identity is more complex than traditional application identity because:

1. **Delegation**: Agents act *on behalf of* users, requiring clear authorization chains
2. **Multi-service access**: A single agent may need tokens for GitHub, Gmail, Slack, and more
3. **Dynamic tool discovery**: Agents discover MCP servers at runtime, requiring dynamic credential management
4. **Autonomy vs. control**: Balancing agent autonomy with user oversight and consent

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                         User (Resource Owner)                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                    ‚îÇ
                         OAuth 2.1 Authorization
                                    ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                        Agent Runtimes Server                        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ  Token Manager  ‚îÇ  ‚îÇ  Agent Context  ‚îÇ  ‚îÇ  MCP Client         ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  (OAuth flows)  ‚îÇ  ‚îÇ  (User identity)‚îÇ  ‚îÇ  (Tool invocation)  ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚îÇ                    ‚îÇ                       ‚îÇ
            ‚ñº                    ‚ñº                       ‚ñº
     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     ‚îÇ   GitHub     ‚îÇ     ‚îÇ   Gmail      ‚îÇ       ‚îÇ  Kaggle MCP  ‚îÇ
     ‚îÇ   API        ‚îÇ     ‚îÇ   API        ‚îÇ       ‚îÇ  Server      ‚îÇ
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Identity Types

### Type 1: User-Delegated Access (OAuth 2.1)

**Use case**: Agent accesses user's GitHub repositories, Gmail, or other personal services.

The agent acts as an OAuth client, obtaining tokens that represent the user's delegated authorization. This follows the standard [OAuth 2.1](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12) authorization code flow with [PKCE](https://oauth.net/2/pkce/) (Proof Key for Code Exchange).

:::info Security Architecture
Based on the agent identity landscape, there are different approaches depending on your trust model:

| Scenario | Recommended Approach | Agent Runtimes Support |
|----------|---------------------|----------------------|
| **Public agents** (internet-facing) | PKCE + DCR | ‚úÖ Both implemented |
| **Internal agents** (within org) | SPIFFE/SPIRE | üîú Planned |
| **Service-to-service** | Client Credentials | ‚úÖ Conceptual support |

The implementation provides:
- **PKCE** for secure authorization code flows with public clients
- **DCR** (Dynamic Client Registration) for agents that discover OAuth providers at runtime
:::

```python
# User initiates OAuth flow through the UI
# Agent receives delegated access token
agent_context = AgentContext(
    user_id="user-123",
    oauth_tokens={
        "github": GitHubToken(access_token="gho_...", scopes=["repo", "read:user"]),
        "gmail": GmailToken(access_token="ya29...", scopes=["gmail.readonly"]),
    }
)

# Agent tools use these tokens
@agent.tool
async def list_repos(ctx: RunContext[AgentContext]) -> list[dict]:
    token = ctx.deps.oauth_tokens["github"]
    async with httpx.AsyncClient() as client:
        response = await client.get(
            "https://api.github.com/user/repos",
            headers={"Authorization": f"Bearer {token.access_token}"}
        )
        return response.json()
```

### Type 2: MCP Server Authentication

**Use case**: Agent connects to an MCP server that requires OAuth authentication (e.g., [Kaggle MCP](https://www.kaggle.com/docs/mcp)).

MCP servers follow the [MCP Authorization Specification](https://modelcontextprotocol.io/specification/2025-03-26/basic/authorization) based on OAuth 2.1.

```json
{
  "mcpServers": {
    "kaggle": {
      "url": "https://www.kaggle.com/mcp",
      "auth": {
        "type": "oauth2",
        "clientId": "your-client-id",
        "scopes": ["datasets:read", "notebooks:execute"]
      }
    }
  }
}
```

When the agent invokes a Kaggle MCP tool, the runtime:
1. Checks if a valid token exists for this user + MCP server
2. If not, initiates OAuth flow (user sees consent screen)
3. Stores the token securely
4. Attaches token to MCP requests

### Type 3: Agent-to-Agent Communication (SPIFFE/SPIRE)

**Use case**: Internal agents communicating within your organization's infrastructure.

For workload-to-workload identity within a trust domain, use [SPIFFE](https://spiffe.io) (Secure Production Identity Framework for Everyone):

```python
from agent_runtimes.identity import SPIFFEIdentity

# Agent obtains its SVID (SPIFFE Verifiable Identity Document)
identity = SPIFFEIdentity()
svid = await identity.get_x509_svid()

# Use SVID for mutual TLS with other agents
async with identity.create_secure_channel("spiffe://acme.com/agents/data-processor") as channel:
    response = await channel.request({"action": "process_data", "payload": data})
```

SPIFFE provides:
- **Automatic identity**: No static credentials‚Äîworkloads receive short-lived certificates
- **Zero-trust**: Every request is authenticated via mutual TLS
- **Cross-platform**: Works with Kubernetes, VMs, bare metal

### Type 4: Service Account Access

**Use case**: Agent accesses backend services using application-level credentials.

For server-to-server communication where no user is involved, use the OAuth 2.1 Client Credentials flow:

```python
from agent_runtimes.identity import ServiceCredentials

# Configure service account
service = ServiceCredentials(
    client_id=os.getenv("ANALYTICS_CLIENT_ID"),
    client_secret=os.getenv("ANALYTICS_CLIENT_SECRET"),
    token_endpoint="https://auth.example.com/oauth/token",
    scopes=["analytics:read"]
)

# Agent uses service token (auto-refreshed)
@agent.tool
async def get_metrics(ctx: RunContext) -> dict:
    token = await service.get_token()
    # Use token for API calls
```

## Provider Setup Guides

This section provides step-by-step instructions for setting up OAuth with common providers.

### GitHub OAuth App Setup

For GitHub identity, you can use either a **GitHub OAuth App** or a **GitHub App**. The choice depends on your use case.

:::warning GitHub Does NOT Support DCR
GitHub does not support OAuth 2.0 Dynamic Client Registration (RFC 7591). You must:
1. **Pre-register** your app manually in GitHub Developer Settings
2. Use the **same client_id** for all users
3. Obtain **per-user access tokens** via the standard OAuth flow
4. Store tokens mapped to your internal user identity

This is the standard GitHub model and applies to most consumer OAuth providers (Google, etc.).
:::

:::info GitHub OAuth App vs GitHub App - Which to Choose?

| Feature | OAuth App | GitHub App |
|---------|-----------|------------|
| **Setup complexity** | Simple | More complex |
| **Permissions** | Broad scopes | Fine-grained per-resource |
| **Installation model** | Per-user OAuth | Per-user/org installation |
| **Token lifetime** | Long-lived | Short-lived (1 hour) |
| **Best for** | Simple auth, read-only | Agents acting on repos |

**For AI agents that will**:
- Create repos, open PRs, read/write issues
- Act repeatedly on a user's behalf
- Need fine-grained permissions

üëâ **Use a GitHub App** (recommended for agent-style use cases)

**For simple authentication**:
- Just need to identify the user
- Read-only access to public data
- Simple integration

üëâ **Use an OAuth App**

Agent Runtimes currently supports OAuth Apps. GitHub App support is planned.
:::

#### Security Model: PKCE + DCR (Where Supported)

Agent Runtimes implements **OAuth 2.1 Authorization Code flow with PKCE** and **Dynamic Client Registration (DCR)**:

| Feature | Implemented? | Notes |
|---------|--------------|-------|
| **PKCE** | ‚úÖ Yes | Protects against authorization code interception attacks |
| **DCR** | ‚úÖ Yes | For providers that support it (Okta, Auth0, Keycloak) |
| **Device Flow** | ‚ùå No | Not needed‚Äîwe use browser-based redirect/popup flow |

:::caution DCR Provider Support
**Most consumer OAuth providers do NOT support DCR:**
- ‚ùå GitHub - manual registration required
- ‚ùå Google - manual registration required  
- ‚ö†Ô∏è Azure AD - tenant-admin only

**Enterprise identity providers typically DO support DCR:**
- ‚úÖ Okta
- ‚úÖ Auth0
- ‚úÖ Keycloak

For GitHub, Google, and similar providers, you must pre-register your OAuth app manually.
:::
| **Dynamic Client Registration (DCR)** | ‚úÖ Yes | Register clients dynamically with OAuth providers |
| **Device Flow** | ‚ùå No | Not needed‚Äîwe use browser-based redirect/popup flow |

:::tip Why PKCE?
PKCE adds security for public clients (like browser apps) that can't securely store a client secret. The flow works as follows:

1. **Client generates** a random `code_verifier` (kept secret)
2. **Client sends** a SHA-256 hash of the verifier (`code_challenge`) in the authorization request
3. **Authorization server stores** the challenge
4. **During token exchange**, client sends the original `code_verifier`
5. **Server verifies** that `SHA256(code_verifier) == code_challenge`

This prevents attackers who intercept the authorization code from exchanging it for tokens, since they don't have the original `code_verifier`.
:::

:::tip Dynamic Client Registration (DCR)
DCR ([RFC 7591](https://oauth.net/2/dynamic-client-registration/)) allows clients to register themselves dynamically without manual setup. Agent Runtimes implements DCR for:
- Agents that connect to arbitrary OAuth providers discovered at runtime
- MCP servers that require OAuth authentication
- Multi-tenant SaaS where each tenant brings their own OAuth provider

**When to use DCR**:
- Agent discovers an MCP server with an unknown OAuth provider
- You want zero-configuration OAuth setup
- The OAuth provider supports DCR (check for `registration_endpoint` in server metadata)

**When NOT to use DCR**:
- OAuth provider doesn't support DCR (e.g., GitHub, Google)
- You need specific branding/settings only available via manual registration
- Enterprise OAuth with restricted registration

See [Dynamic Client Registration](#dynamic-client-registration-dcr) section below for usage examples.
:::

#### GitHub OAuth Settings FAQ

**Do I need to enable "Enable Device Flow"?**

No. Device Flow is for devices that can't easily display a web browser (smart TVs, CLI tools, IoT devices). Agent Runtimes uses the standard **Authorization Code flow** with browser redirects or popups, so Device Flow is not needed.

**What about "Require PKCE for OAuth Apps"?**

If GitHub offers this option, you can enable it for extra security. Agent Runtimes always uses PKCE regardless of whether GitHub requires it.

#### Step 1: Create the OAuth App

1. Go to [GitHub Developer Settings](https://github.com/settings/developers)
2. Click **OAuth Apps** in the left sidebar
3. Click **New OAuth App** (or **Register a new application**)

#### Step 2: Configure the Application

Fill in the registration form:

| Field | Value | Notes |
|-------|-------|-------|
| **Application name** | `My Agent App` | User-visible name shown during authorization |
| **Homepage URL** | `http://localhost:3000` | Your application's homepage (can be localhost for dev) |
| **Application description** | Optional | Helps users understand what your app does |
| **Authorization callback URL** | `http://localhost:3000/index-examples.html` | **Critical**: Must match the exact page URL |
| **Enable Device Flow** | ‚ùå Unchecked | Not needed for browser-based flows |

:::warning Callback URL Must Match Your Page URL
The callback URL redirects back to **the same page** that initiated the OAuth flow. This means:

**For the Agent Runtimes examples:**
```
http://localhost:3000/index-examples.html
```

**For a custom app at the root:**
```
http://localhost:3000/
```

**For production:**
```
https://myapp.example.com/your-app-page.html
```

The identity module automatically uses `window.location.pathname` as the callback URL, so OAuth returns to the same page. The code then extracts the `code` and `state` params from the URL and completes the flow.
:::

#### Step 3: Get Your Credentials

After creating the app:

1. Copy the **Client ID** - this is public and safe to include in frontend code
2. *(Optional)* Click **Generate a new client secret** - only needed for server-side flows

:::tip Client Secret for PKCE
For browser-based OAuth with PKCE, the client secret is **optional**. However, if you have one, the backend token exchange endpoint will use it.
:::

#### Step 4: Configure Agent Runtimes

**Environment Variables**:

Create a `.env` file in your project root:

```bash
# .env (for Vite-based projects)

# Frontend (Vite) - used by React components
VITE_GITHUB_CLIENT_ID=your_github_client_id_here

# Backend (Python) - used by token exchange endpoint
GITHUB_CLIENT_ID=your_github_client_id_here
# GITHUB_CLIENT_SECRET=your_secret_here  # Optional for PKCE
```

:::warning Both Frontend AND Backend Need the Client ID
The OAuth flow requires the client ID in two places:
1. **Frontend** (`VITE_GITHUB_CLIENT_ID`) - to build the authorization URL
2. **Backend** (`GITHUB_CLIENT_ID`) - to exchange the code for a token

GitHub doesn't support CORS on their token endpoint, so the backend proxies the token exchange.
:::

:::info Client Secret NOT Required
**You do NOT need to set a client secret** for browser-based OAuth flows.

Agent Runtimes uses **OAuth 2.1 with PKCE** (Proof Key for Code Exchange), which is designed for public clients (browsers, mobile apps) where secrets cannot be stored securely.

| Flow Type | Client Secret | Security Mechanism |
|-----------|---------------|-------------------|
| **Browser/SPA (PKCE)** | ‚ùå Not needed | Dynamic `code_verifier` + `code_challenge` |
| **Server-side** | ‚úÖ Required | Static secret stored securely on server |

For the examples and browser-based identity flows, **only set the Client ID variables**.
:::

:::tip Demo Mode
The Agent Runtimes examples use a fallback `demo-client-id` when no environment variable is set. This allows the UI to render, but the OAuth flow won't work until you provide a real GitHub OAuth App client ID.

To see the identity UI in action:
1. The "Connected Accounts" section will appear in the agent configuration form
2. Clicking "Connect GitHub" will attempt the OAuth flow
3. Without a real client ID, GitHub will show an error
:::

**Using with AgentSpaceFormExample**:

The example component reads the client ID from environment:

```tsx
// In AgentSpaceFormExample.tsx
const GITHUB_CLIENT_ID = import.meta.env.VITE_GITHUB_CLIENT_ID || 'demo-client-id';

// Later in the component:
const identityProviders = React.useMemo(() => {
  const providers = {};
  if (githubClientId) {
    providers.github = {
      clientId: githubClientId,
      scopes: ['read:user', 'user:email', 'repo'],
    };
  }
  return providers;
}, [githubClientId]);
```

**Frontend (React) - Custom Implementation**:

```tsx
// Set via environment variable (safe for frontend - public value)
// In .env or .env.local:
// VITE_GITHUB_CLIENT_ID=your_client_id_here

import { IdentityConnect } from '@datalayer/agent-runtimes';

function App() {
  return (
    <IdentityConnect
      providers={{
        github: {
          clientId: import.meta.env.VITE_GITHUB_CLIENT_ID,
          scopes: ['read:user', 'user:email', 'repo'],
        },
      }}
    />
  );
}
```

**Backend (Python)** - Only needed for server-side token exchange:

:::caution When is a Client Secret Needed?
The client secret is **only required** if your backend server performs the OAuth token exchange (confidential client flow). 

For browser-only flows using PKCE, the token exchange happens in the browser and **no secret is needed**.
:::

```bash
# In your .env file (never commit this!)
# Only needed for server-side OAuth flows
GITHUB_CLIENT_ID=your_client_id
GITHUB_CLIENT_SECRET=your_client_secret  # Only for server-side flows
```

```python
# In your agent server configuration (if doing server-side token exchange)
import os

OAUTH_PROVIDERS = {
    "github": {
        "client_id": os.getenv("GITHUB_CLIENT_ID"),
        "client_secret": os.getenv("GITHUB_CLIENT_SECRET"),  # Optional for PKCE
        "authorization_endpoint": "https://github.com/login/oauth/authorize",
        "token_endpoint": "https://github.com/login/oauth/access_token",
        "userinfo_endpoint": "https://api.github.com/user",
    }
}
```

#### Step 5: Set Up the Callback Route

Mount the `OAuthCallback` component at your callback URL:

```tsx
// Using React Router
import { OAuthCallback } from '@datalayer/agent-runtimes';
import { Routes, Route } from 'react-router-dom';

function App() {
  return (
    <Routes>
      <Route path="/" element={<MainApp />} />
      <Route 
        path="/oauth/callback" 
        element={<OAuthCallback redirectUrl="/" />} 
      />
    </Routes>
  );
}
```

#### GitHub OAuth Scopes Reference

| Scope | Access | Use Case |
|-------|--------|----------|
| `read:user` | Read user profile | Basic identity verification |
| `user:email` | Read user email | Contact information |
| `repo` | Full repository access | Read/write code, issues, PRs |
| `public_repo` | Public repositories only | Read/write public repos |
| `repo:status` | Commit status | CI/CD integrations |
| `read:org` | Read org membership | Organization-aware features |
| `gist` | Create/read gists | Code snippet sharing |

**Recommended minimum scopes**: `read:user`, `user:email`

**For repository access**: Add `repo` (private) or `public_repo` (public only)

#### Testing Your Setup

1. Start your development server:
   ```bash
   npm run dev
   ```

2. Click "Connect GitHub" in your app

3. You should be redirected to GitHub's authorization page

4. After authorizing, you'll be redirected back to your callback URL

5. The `OAuthCallback` component handles the token exchange automatically

#### Troubleshooting

**"The redirect_uri is not valid"**
- Ensure your callback URL in GitHub settings exactly matches your app's URL
- Check for trailing slashes - `http://localhost:3000/oauth/callback` ‚â† `http://localhost:3000/oauth/callback/`
- Verify the protocol matches (http vs https)

**"Bad credentials" on API calls**
- Token may have expired - implement token refresh
- Scopes may be insufficient - request additional scopes

**CORS errors**
- GitHub's token endpoint doesn't support CORS
- Token exchange must happen on your backend server
- Agent Runtimes provides `/api/v1/identity/oauth/token` endpoint for this

### Google OAuth Setup

For Google/Gmail identity, use Google Cloud Console:

1. Go to [Google Cloud Console](https://console.cloud.google.com/)
2. Create a project or select an existing one
3. Navigate to **APIs & Services** ‚Üí **Credentials**
4. Click **Create Credentials** ‚Üí **OAuth client ID**
5. Select **Web application**
6. Add authorized redirect URIs (same pattern as GitHub)
7. Copy the Client ID and Client Secret

```tsx
<IdentityConnect
  providers={{
    google: {
      clientId: import.meta.env.VITE_GOOGLE_CLIENT_ID,
      scopes: ['openid', 'profile', 'email', 'https://www.googleapis.com/auth/gmail.readonly'],
    },
  }}
/>
```

### Kaggle OAuth Setup

Kaggle uses OAuth 2.1 for MCP server authentication:

1. Go to [Kaggle Account Settings](https://www.kaggle.com/settings)
2. Scroll to **API** section
3. Create API credentials
4. Configure your MCP server connection:

```json
{
  "mcpServers": {
    "kaggle": {
      "url": "https://www.kaggle.com/mcp",
      "auth": {
        "type": "oauth2",
        "clientId": "your-kaggle-client-id",
        "scopes": ["datasets:read", "notebooks:read"]
      }
    }
  }
}
```

## Dynamic Client Registration (DCR)

Dynamic Client Registration allows OAuth clients to register themselves automatically with authorization servers, without manual app creation. This is essential for AI agents that discover OAuth-protected services at runtime.

### When to Use DCR

| Scenario | Use DCR? | Notes |
|----------|----------|-------|
| **Known providers** (GitHub, Google) | ‚ùå No | These don't support DCR; use manual registration |
| **MCP servers** with OAuth | ‚úÖ Yes | Agent discovers MCP servers dynamically |
| **Enterprise IdPs** (Okta, Auth0) | ‚úÖ Maybe | Check if DCR is enabled |
| **OpenID Connect providers** | ‚úÖ Yes | Most OIDC providers support DCR |

### How DCR Works

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                         Dynamic Client Registration Flow                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

1. Agent discovers OAuth provider
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ  Agent  ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂   ‚îÇ /.well-known/oauth- ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   GET metadata     ‚îÇ authorization-server‚îÇ
                                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

2. Agent registers itself dynamically
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ  Agent  ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂   ‚îÇ /register           ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   POST client      ‚îÇ (DCR endpoint)      ‚îÇ
                 metadata         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                           ‚îÇ
                 ‚óÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 Returns: client_id, client_secret (optional)

3. Agent uses registered credentials for OAuth
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ  Agent  ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂   ‚îÇ /authorize          ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   Standard OAuth   ‚îÇ (with new client_id)‚îÇ
                 + PKCE           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Using DCR in Agent Runtimes

#### Discovering and Registering

```typescript
import { 
  discoverAuthorizationServer, 
  supportsDCR,
  getOrCreateDynamicClient,
  dynamicClientToProviderConfig,
} from '@datalayer/agent-runtimes';

// Example: Agent discovers a new MCP server that requires OAuth
async function connectToMcpServer(mcpServerUrl: string) {
  // 1. Discover the authorization server metadata
  const issuerUrl = 'https://auth.example.com';
  const metadata = await discoverAuthorizationServer(issuerUrl);
  
  if (!metadata) {
    throw new Error('Could not discover OAuth server');
  }
  
  // 2. Check if DCR is supported
  if (!supportsDCR(metadata)) {
    throw new Error('Server does not support Dynamic Client Registration');
  }
  
  // 3. Register dynamically (or retrieve existing registration)
  const client = await getOrCreateDynamicClient(issuerUrl, {
    clientName: 'My AI Agent',
    redirectUris: ['http://localhost:3000/oauth/callback'],
    scopes: ['openid', 'profile', 'mcp:tools'],
  });
  
  console.log('Registered client:', client.clientId);
  
  // 4. Convert to provider config for use with identity system
  const providerConfig = dynamicClientToProviderConfig(client, 'Example Service');
  
  // 5. Now use standard OAuth flow with the dynamic client
  // The identity system will use client.clientId for authorization
}
```

#### Managing Dynamic Clients

```typescript
import {
  loadDynamicClient,
  getAllDynamicClients,
  removeDynamicClient,
  clearAllDynamicClients,
} from '@datalayer/agent-runtimes';

// Load a specific client
const client = loadDynamicClient('https://auth.example.com');

// List all registered clients
const allClients = getAllDynamicClients();
console.log(`Registered with ${allClients.length} OAuth providers`);

// Remove a client (useful when revoking access)
removeDynamicClient('https://auth.example.com');

// Clear all (useful for testing or user logout)
clearAllDynamicClients();
```

### DCR Request Format

When Agent Runtimes registers a client, it sends a request like this:

```json
{
  "redirect_uris": ["http://localhost:3000/oauth/callback"],
  "client_name": "Agent Runtimes Client",
  "grant_types": ["authorization_code", "refresh_token"],
  "response_types": ["code"],
  "token_endpoint_auth_method": "none"
}
```

The `token_endpoint_auth_method: "none"` indicates a **public client** that uses PKCE instead of a client secret.

### DCR Response

The authorization server responds with:

```json
{
  "client_id": "dynamically-generated-id",
  "client_secret": "optional-secret",
  "client_secret_expires_at": 0,
  "registration_access_token": "token-for-updates",
  "registration_client_uri": "https://auth.example.com/clients/dynamically-generated-id"
}
```

Agent Runtimes stores this information locally for future use, so re-registration isn't needed on every request.

### Providers That Support DCR

| Provider | DCR Support | Notes |
|----------|-------------|-------|
| **Okta** | ‚úÖ Yes | `/.well-known/openid-configuration` |
| **Auth0** | ‚úÖ Yes | `/.well-known/openid-configuration` |
| **Keycloak** | ‚úÖ Yes | `/.well-known/openid-configuration` |
| **Azure AD** | ‚ö†Ô∏è Limited | Tenant-admin only, requires special configuration |
| **GitHub** | ‚ùå No | Manual OAuth App or GitHub App registration |
| **Google** | ‚ùå No | Manual registration via Google Cloud Console |
| **Kaggle** | üîú TBD | Check MCP server documentation |

:::note Most Consumer Providers Don't Support DCR
GitHub is not unusual here. Most consumer-facing OAuth providers (GitHub, Google, Facebook, etc.) require manual app registration for security and abuse prevention reasons.

DCR is primarily useful for:
- Enterprise identity providers (Okta, Auth0)
- MCP servers that implement their own OAuth
- Multi-tenant SaaS with customer-provided IdPs
:::

### Security Considerations

:::warning DCR Security
- **Protected endpoints**: Some servers require an initial access token to register clients. Use the `initialAccessToken` option.
- **Client secrets**: Dynamic clients may receive secrets that should be stored securely.
- **Expiration**: Client secrets may expire; check `client_secret_expires_at` and re-register when needed.
- **Scope validation**: Servers may grant fewer scopes than requested; always check the response.
:::

## Implementation Strategy

### Phase 1: OAuth 2.1 Foundation

Implement OAuth 2.1 with the following components:

```
agent_runtimes/
  identity/
    __init__.py
    oauth/
      client.py          # OAuth client implementation
      tokens.py          # Token storage and refresh
      pkce.py            # PKCE utilities
      discovery.py       # Authorization server metadata (RFC 8414)
      dcr.py             # Dynamic Client Registration (RFC 7591)
    providers/
      github.py          # GitHub OAuth configuration
      google.py          # Google/Gmail OAuth configuration
      kaggle.py          # Kaggle OAuth configuration
      generic.py         # Generic OAuth provider
```

#### Token Storage

Tokens must be stored securely with:
- **Encryption at rest**: AES-256 encryption for stored tokens
- **User scoping**: Tokens are always associated with a specific user
- **Automatic refresh**: Background refresh before expiration
- **Revocation support**: Clear tokens on user logout or revocation

```python
class TokenStore:
    """Secure token storage with automatic refresh."""
    
    async def store_token(
        self,
        user_id: str,
        provider: str,
        token: OAuthToken,
    ) -> None:
        """Store encrypted token for user."""
        
    async def get_token(
        self,
        user_id: str,
        provider: str,
    ) -> OAuthToken | None:
        """Get token, refreshing if needed."""
        
    async def revoke_token(
        self,
        user_id: str,
        provider: str,
    ) -> None:
        """Revoke and delete token."""
```

#### Dynamic Client Registration

For MCP servers the agent hasn't seen before, the frontend implements [RFC 7591](https://datatracker.ietf.org/doc/html/rfc7591) Dynamic Client Registration. See the [DCR section](#dynamic-client-registration-dcr) above for full documentation.

The backend Python equivalent:

```python
from agent_runtimes.identity.dcr import (
    discover_authorization_server,
    register_client,
    get_or_create_dynamic_client,
)

# Discover and register with a new OAuth provider
async def connect_to_new_provider(issuer_url: str) -> DynamicClient:
    """Register with an OAuth provider discovered at runtime."""
    return await get_or_create_dynamic_client(
        issuer_url=issuer_url,
        client_name="My AI Agent",
        redirect_uris=["http://localhost:3000/oauth/callback"],
        scopes=["openid", "profile"],
    )
```

### Phase 2: MCP Authorization Integration

Extend the MCP client to handle OAuth authentication automatically:

```python
class AuthenticatedMCPClient:
    """MCP client with automatic OAuth handling."""
    
    def __init__(
        self,
        server_url: str,
        token_store: TokenStore,
        user_id: str,
    ):
        self.server_url = server_url
        self.token_store = token_store
        self.user_id = user_id
        
    async def call_tool(
        self,
        tool_name: str,
        arguments: dict,
    ) -> Any:
        # Get or refresh token
        token = await self.token_store.get_token(
            self.user_id,
            provider=self._get_provider_key()
        )
        
        if token is None:
            # Trigger OAuth flow
            raise AuthorizationRequired(
                provider=self._get_provider_key(),
                auth_url=await self._get_auth_url(),
            )
        
        # Call MCP tool with authorization header
        headers = {"Authorization": f"Bearer {token.access_token}"}
        return await self._execute_tool(tool_name, arguments, headers)
```

### Phase 3: Token Broker Architecture (Advanced)

For production deployments with many connectors, consider a centralized token broker:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                         Token Broker                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ  Token Vault    ‚îÇ  ‚îÇ  Policy Engine  ‚îÇ  ‚îÇ  Audit Logger       ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  (encrypted)    ‚îÇ  ‚îÇ  (scopes/limits)‚îÇ  ‚îÇ  (compliance)       ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚îÇ                    ‚îÇ                       ‚îÇ
     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     ‚îÇ   Agent 1   ‚îÇ      ‚îÇ   Agent 2   ‚îÇ        ‚îÇ   Agent N   ‚îÇ
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

Benefits:
- **Centralized governance**: Admins control all token policies
- **Automatic rotation**: Tokens are refreshed before expiry
- **Audit trail**: Every token use is logged
- **Scoped access**: Agents only see tokens they're authorized for

## Security Best Practices

### 1. Use PKCE for All OAuth Flows

All authorization code flows MUST use [PKCE](https://oauth.net/2/pkce/) (Proof Key for Code Exchange):

```python
import secrets
import hashlib
import base64

def generate_pkce_pair() -> tuple[str, str]:
    """Generate PKCE code verifier and challenge."""
    code_verifier = secrets.token_urlsafe(64)
    code_challenge = base64.urlsafe_b64encode(
        hashlib.sha256(code_verifier.encode()).digest()
    ).decode().rstrip("=")
    return code_verifier, code_challenge
```

### 2. Minimize Token Lifetimes

- **Access tokens**: 1 hour maximum
- **Refresh tokens**: 7 days maximum, with rotation on use
- **MCP session tokens**: Scope to single session when possible

### 3. Request Minimum Scopes

```python
# ‚ùå Don't request broad scopes
scopes = ["repo", "user", "admin:org"]

# ‚úÖ Request only what's needed
scopes = ["repo:read", "user:email"]
```

### 4. Implement Token Revocation

When a user disconnects a service or logs out:

```python
async def disconnect_provider(user_id: str, provider: str) -> None:
    """Revoke tokens and clean up."""
    token = await token_store.get_token(user_id, provider)
    if token:
        # Revoke at provider
        await provider_client.revoke_token(token)
        # Delete locally
        await token_store.delete_token(user_id, provider)
```

### 5. Secure Token Storage

Never store tokens in:
- ‚ùå Environment variables (except for local development)
- ‚ùå Browser localStorage/sessionStorage
- ‚ùå Unencrypted databases
- ‚ùå Log files

Instead use:
- ‚úÖ Encrypted database columns
- ‚úÖ Hardware security modules (HSM) for production
- ‚úÖ Secret managers (Vault, AWS Secrets Manager, GCP Secret Manager)

## UI Integration

The Agent Runtimes React components support OAuth flows out of the box:

```tsx
import { ChatBase, useOAuthConnect } from '@datalayer/agent-runtimes';

function AgentChat() {
  const { connect, isConnecting, connectedProviders } = useOAuthConnect();
  
  return (
    <div>
      {/* Show connection status */}
      <div className="providers">
        <button 
          onClick={() => connect('github')}
          disabled={connectedProviders.includes('github')}
        >
          {connectedProviders.includes('github') ? '‚úì GitHub Connected' : 'Connect GitHub'}
        </button>
        <button onClick={() => connect('kaggle')}>
          Connect Kaggle
        </button>
      </div>
      
      {/* Chat component handles authorization-required responses */}
      <ChatBase
        onAuthorizationRequired={({ provider, authUrl }) => {
          // Open OAuth popup
          window.open(authUrl, 'oauth', 'width=600,height=800');
        }}
      />
    </div>
  );
}
```

## Emerging Standards

### OpenID Connect for Agents (OIDC-A)

[OIDC-A 1.0](https://arxiv.org/abs/2509.25974) is an emerging extension to OpenID Connect specifically designed for LLM-based agents. Key features:

- **Agent identity claims**: Standard claims for agent type, capabilities, and attestation
- **Delegation chains**: Cryptographic proof of authorization delegation from user to agent
- **Capability tokens**: Fine-grained authorization based on agent capabilities

While OIDC-A is still emerging, Agent Runtimes will track its development and adopt relevant patterns as the specification matures.

### A2A Identity

The [A2A (Agent-to-Agent) protocol](https://google.github.io/a2a/) includes identity provisions for inter-agent communication, complementing the transports layer documented in [Transports](/transports).

## Configuration Reference

### Environment Variables

```bash
# OAuth provider credentials (for built-in providers)
GITHUB_CLIENT_ID=your-github-client-id
GITHUB_CLIENT_SECRET=your-github-client-secret

GOOGLE_CLIENT_ID=your-google-client-id
GOOGLE_CLIENT_SECRET=your-google-client-secret

# Token encryption key (required for production)
TOKEN_ENCRYPTION_KEY=your-256-bit-key-base64

# Token storage backend
TOKEN_STORE_TYPE=database  # or "memory", "redis", "vault"
TOKEN_STORE_URL=postgresql://user:pass@localhost/tokens
```

### MCP Server Authentication Config

```json
{
  "mcpServers": {
    "kaggle": {
      "url": "https://www.kaggle.com/mcp",
      "auth": {
        "type": "oauth2",
        "discoveryUrl": "https://www.kaggle.com/.well-known/oauth-authorization-server",
        "scopes": ["datasets:read", "notebooks:read"],
        "clientId": "your-kaggle-client-id"
      }
    },
    "github": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-github"],
      "env": {
        "GITHUB_TOKEN": "${GITHUB_USER_TOKEN}"
      }
    },
    "filesystem": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-filesystem", "/allowed/path"],
      "auth": null
    }
  }
}
```

## Further Reading

- [OAuth 2.1 Draft Specification](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12)
- [MCP Authorization Specification](https://modelcontextprotocol.io/specification/2025-03-26/basic/authorization)
- [SPIFFE Concepts](https://spiffe.io/docs/latest/spiffe-about/spiffe-concepts/)
- [RFC 7591 - OAuth 2.0 Dynamic Client Registration](https://datatracker.ietf.org/doc/html/rfc7591)
- [RFC 8414 - OAuth 2.0 Authorization Server Metadata](https://datatracker.ietf.org/doc/html/rfc8414)
- [PKCE (RFC 7636)](https://oauth.net/2/pkce/)
- [Secure Token Management for AI Agents](https://www.scalekit.com/blog/secure-token-management-ai-agents)
